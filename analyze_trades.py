import pandas as pd
import glob
import os
import re
import shutil

def analyze_latest_run():
    # 1. Find the most recent CSV file generated by the bot
    csv_files = glob.glob("PredictionLiveTrader/LivePaperTrades_*.csv")
    
    # Filter out our snapshot file so we don't accidentally analyze an old snapshot
    valid_files = [f for f in csv_files if "SNAPSHOT" not in f]

    if not valid_files:
        print("No CSV files found! Make sure the bot has exported a ledger.")
        return

    latest_file = max(valid_files, key=os.path.getctime)
    
    # 2. THE SAFE CLONE: Copy the live file to a snapshot so C# doesn't get blocked!
    snapshot_file = "PredictionLiveTrader/LivePaperTrades_SNAPSHOT.csv"
    try:
        shutil.copy2(latest_file, snapshot_file)
        print(f"\nðŸ“¸ Created safe snapshot: {os.path.basename(latest_file)}")
    except Exception as e:
        print(f"Failed to create snapshot: {e}")
        return

    print("="*80)
    print(f"ðŸ“Š ANALYZING SNAPSHOT DATA")
    print("="*80)

    # 3. Load the data from the SNAPSHOT, not the live file
    df = pd.read_csv(snapshot_file)

    if df.empty:
        print("CSV is empty â€” no trades to analyze yet.")
        return

    # Convert Timestamp to actual DateTime objects for time-based analysis
    df['Timestamp'] = pd.to_datetime(df['Timestamp'])

    # 4. Handle all trade sides correctly
    buy_sides = {'BUY', 'BUY NO'}
    df['CashFlow'] = df.apply(
        lambda row: -row['DollarValue'] if row['Side'] in buy_sides else row['DollarValue'],
        axis=1
    )

    # Extract starting capital per strategy from CSV (falls back to $1000 for old CSVs)
    if 'StartingCapital' in df.columns:
        starting_caps = df.drop_duplicates('StrategyName').set_index('StrategyName')['StartingCapital'].to_dict()
    else:
        starting_caps = {}

    # Extract strategy type and parameters
    df['StrategyType'] = df['StrategyName'].apply(lambda x: x.split('_v')[0].split('_Ultra')[0])

    def extract_params(name):
        params = re.findall(r'_([A-Z])([0-9.]+)', name)
        return {k: float(v) for k, v in params}

    df['Params'] = df['StrategyName'].apply(extract_params)

    # ==========================================
    # DASHBOARD 1: STRATEGY LEADERBOARD
    # ==========================================
    print("\nðŸ† STRATEGY LEADERBOARD (Sorted by Profit)")
    print("-" * 80)

    leaderboard = df.groupby('StrategyName').agg(
        Total_PnL=('CashFlow', 'sum'),
        Buys=('Side', lambda x: x.isin(buy_sides).sum()),
        Sells=('Side', lambda x: (~x.isin(buy_sides)).sum()),
    ).reset_index()

    leaderboard = leaderboard.sort_values('Total_PnL', ascending=False)
    leaderboard['Total_PnL_fmt'] = leaderboard['Total_PnL'].apply(lambda x: f"${x:,.2f}")
    
    # NEW: Calculate approximate Win Rate based on paired Buys/Sells
    leaderboard['WinRate%'] = (leaderboard['Sells'] / (leaderboard['Buys'] + leaderboard['Sells']) * 100).fillna(0).apply(lambda x: f"{x:.1f}%")

    print(leaderboard[['StrategyName', 'Total_PnL_fmt', 'Buys', 'Sells', 'WinRate%']].to_string(index=False))

    # ==========================================
    # DASHBOARD 2: PARAMETER IMPACT ANALYSIS
    # ==========================================
    print("\nðŸ”¬ PARAMETER IMPACT (Which settings work best?)")
    print("-" * 80)

    all_params = df['Params'].apply(pd.Series).stack().reset_index(level=1)
    all_params.columns = ['Param', 'Value']
    all_params['CashFlow'] = df.loc[all_params.index, 'CashFlow']
    all_params['StrategyName'] = df.loc[all_params.index, 'StrategyName']

    strategy_pnl = df.groupby('StrategyName')['CashFlow'].sum().reset_index()
    strategy_pnl.columns = ['StrategyName', 'StrategyPnL']

    param_names = {'T': 'Threshold', 'W': 'Window', 'P': 'TakeProfit'}

    for param_letter in sorted(df['Params'].apply(lambda d: list(d.keys())).explode().dropna().unique()):
        param_label = param_names.get(param_letter, param_letter)
        param_vals = df.drop_duplicates('StrategyName')[['StrategyName', 'Params']].copy()
        param_vals['ParamValue'] = param_vals['Params'].apply(lambda d: d.get(param_letter))
        param_vals = param_vals.dropna(subset=['ParamValue'])

        if param_vals.empty:
            continue

        param_vals = param_vals.merge(strategy_pnl, on='StrategyName')
        summary = param_vals.groupby('ParamValue').agg(
            Avg_PnL=('StrategyPnL', 'mean'),
            Strategies=('StrategyName', 'count')
        ).reset_index()

        summary = summary.sort_values('Avg_PnL', ascending=False)
        summary['Avg_PnL'] = summary['Avg_PnL'].apply(lambda x: f"${x:,.2f}")

        print(f"  [{param_label}] (param '{param_letter}')")
        print(summary.to_string(index=False))
        print()

    # ==========================================
    # DASHBOARD 3: HOURLY REGIME ANALYSIS (NEW!)
    # ==========================================
    print("â° HOURLY MARKET REGIME ANALYSIS (When are we making money?)")
    print("-" * 80)
    
    # Group by the Hour of the day and Strategy Type to see timeline trends
    df['Hour'] = df['Timestamp'].dt.floor('H')
    hourly_pnl = df.groupby(['Hour', 'StrategyType'])['CashFlow'].sum().unstack(fill_value=0)
    
    # Format the hourly table as currency
    hourly_pnl_fmt = hourly_pnl.map(lambda x: f"${x:,.2f}")
    print(hourly_pnl_fmt.to_string())
    print("\n")

    # ==========================================
    # DASHBOARD 4: EXECUTION BALANCE
    # ==========================================
    print("âš–ï¸  EXECUTION BALANCE (Are bots holding bags?)")
    print("-" * 80)

    breakdown = df.groupby(['StrategyName', 'Side']).size().unstack(fill_value=0).reset_index()
    print(breakdown.to_string(index=False))
    print("\n")

    """
    # ==========================================
    # DASHBOARD 7: STRATEGY vs. MARKET MATRIX (DETAILED + EXCEL EXPORT)
    # ==========================================
    print("ðŸŽ¯ STRATEGY vs. MARKET MATRIX (Top 10 Markets by Volume)")
    print("-" * 80)
    
    # 1. Find the 10 most heavily traded markets overall
    top_markets = df['MarketName'].value_counts().head(10).index
    
    # 2. Filter our data to only include trades from these top markets
    df_top = df[df['MarketName'].isin(top_markets)].copy()
    
    # 3. Shorten the market names so the table fits on your screen
    df_top['ShortMarket'] = df_top['MarketName'].apply(lambda x: x[:45] + "..." if len(x) > 45 else x)
    
    # 4. Create the Pivot Table: Columns = StrategyName (The specific version!)
    market_matrix = pd.pivot_table(
        df_top, 
        values='CashFlow', 
        index='ShortMarket', 
        columns='StrategyName', 
        aggfunc='sum', 
        fill_value=0
    )
    
    # 5. Add a "Total" column to see the net result for that market
    market_matrix['NET_TOTAL'] = market_matrix.sum(axis=1)
    
    # 6. Sort the Rows (Markets) by activity level
    market_matrix = market_matrix.reindex(df_top['ShortMarket'].value_counts().index)
    
    # 7. Sort the Columns (Strategies) from most profitable to least profitable
    strategy_totals = market_matrix.drop(columns=['NET_TOTAL']).sum().sort_values(ascending=False)
    sorted_columns = list(strategy_totals.index) + ['NET_TOTAL']
    market_matrix = market_matrix[sorted_columns]
    
    # ==========================================
    # THE FIX: Export the raw numbers to CSV!
    # ==========================================
    export_filename = "PredictionLiveTrader/Strategy_Market_Matrix.csv"
    market_matrix.to_csv(export_filename)
    print(f"ðŸ’¾ EXPORT SUCCESS: The detailed matrix has been saved to '{export_filename}'")
    print("   (Open this file in Excel to easily view the full breakdown!)\n")
    
    # 8. Format the numbers as currency for the terminal display
    for col in market_matrix.columns:
        market_matrix[col] = market_matrix[col].apply(lambda x: f"${x:,.2f}")
        
    # 9. Force Pandas to print the whole table (even if it looks messy in the terminal)
    with pd.option_context('display.max_columns', None, 'display.width', 1000):
        print(market_matrix.to_string())
        
    print("\n" + "="*80 + "\n")
    """

    # ==========================================
    # DASHBOARD 8: THE REALITY CHECK (Mark-to-Market Bags)
    # ==========================================
    print("ðŸ’¼ THE REALITY CHECK (Unrealized PnL & Bag Valuation)")
    print("-" * 80)

    # 1. Find the most recent price for every asset based on the latest trades in the CSV
    # This acts as our "Live Market Price" approximation!
    last_prices = df.sort_values('Timestamp').groupby('AssetId')['ExecutionPrice'].last().to_dict()

    # 2. Separate the flow of shares into YES inventory and NO inventory
    df['Yes_Share_Change'] = df.apply(lambda r: r['Shares'] if r['Side'] == 'BUY' else (-r['Shares'] if r['Side'] in ('SELL', 'RESOLVE YES') else 0), axis=1)
    df['No_Share_Change'] = df.apply(lambda r: r['Shares'] if r['Side'] == 'BUY NO' else (-r['Shares'] if r['Side'] in ('SELL NO', 'RESOLVE NO') else 0), axis=1)

    # 3. Calculate the exact number of unsold shares each strategy is holding
    inventory = df.groupby('StrategyName').agg(
        Net_Yes_Shares=('Yes_Share_Change', 'sum'),
        Net_No_Shares=('No_Share_Change', 'sum')
    ).reset_index()

    # 4. Calculate the true Mark-to-Market value of those held bags
    # Liquidity haircut â€” can't assume full exit at last price due to slippage/spread
    LIQUIDITY_HAIRCUT = 0.07  # 7% discount
    inventory['MarkToMarket_Value'] = 0.0

    for idx, row in inventory.iterrows():
        strat = row['StrategyName']
        strat_trades = df[df['StrategyName'] == strat]
        
        # We must value each asset individually for this strategy
        open_assets = strat_trades['AssetId'].unique()
        strat_mtm = 0.0
        
        for asset in open_assets:
            asset_trades = strat_trades[strat_trades['AssetId'] == asset]
            
            yes_held = asset_trades[asset_trades['Side'] == 'BUY']['Shares'].sum() - asset_trades[asset_trades['Side'].isin(['SELL', 'RESOLVE YES'])]['Shares'].sum()
            no_held = asset_trades[asset_trades['Side'] == 'BUY NO']['Shares'].sum() - asset_trades[asset_trades['Side'].isin(['SELL NO', 'RESOLVE NO'])]['Shares'].sum()
            
            last_price = last_prices.get(asset, 0)
            
            # Value of YES shares = shares * current price
            if yes_held > 0:
                strat_mtm += (yes_held * last_price)
                
            # Value of NO shares = shares * (1 - current price)
            if no_held > 0:
                strat_mtm += (no_held * (1 - last_price))
                
        inventory.at[idx, 'MarkToMarket_Value'] = strat_mtm * (1 - LIQUIDITY_HAIRCUT)

    # 5. Bring in the Realized CashFlow we calculated in Dashboard 1
    inventory = inventory.merge(leaderboard[['StrategyName', 'Total_PnL']], on='StrategyName')
    
    # 6. Calculate True Total Equity = StartingCapital + CashFlow PnL + MarkToMarket Bag Value
    inventory['StartingCapital'] = inventory['StrategyName'].map(starting_caps).fillna(1000.0)
    inventory['True_Total_Equity'] = inventory['StartingCapital'] + inventory['Total_PnL'] + inventory['MarkToMarket_Value']
    inventory['True_PnL'] = inventory['True_Total_Equity'] - inventory['StartingCapital']

    # 7. Format and display the reality check!
    inventory = inventory.sort_values('True_PnL', ascending=False)
    
    # Filter out bots that aren't holding anything to keep the view clean
    bag_holders = inventory[(inventory['Net_Yes_Shares'] > 1) | (inventory['Net_No_Shares'] > 1)].copy()
    
    bag_holders['MarkToMarket_Value'] = bag_holders['MarkToMarket_Value'].apply(lambda x: f"${x:,.2f}")
    bag_holders['True_Total_Equity'] = bag_holders['True_Total_Equity'].apply(lambda x: f"${x:,.2f}")
    bag_holders['True_PnL'] = bag_holders['True_PnL'].apply(lambda x: f"${x:,.2f}")
    
    print(bag_holders[['StrategyName', 'MarkToMarket_Value', 'True_Total_Equity', 'True_PnL']].to_string(index=False))
    print("\n" + "="*80 + "\n")

if __name__ == "__main__":
    analyze_latest_run()